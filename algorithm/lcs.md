# Longest Common Subsequence, 최장 공통 부분수열

부분수열이기 때문에 문자 사이를 건너뛰어 공통되면서 가장 긴 부분 문자열을 찾으면 됩니다.

<pre>
<code>
if i == 0 or j == 0:  # 마진 설정
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i - 1][j - 1] + 1
else:
	LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1])
</code>
</pre>
---
<pre>
<code>
         C   A   P   C   A   K
   +---+---+---+---+---+---+---+
A  | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
   +---+---+---+---+---+---+---+
C  | 0 | 1 | 1 | 1 | 2 | 2 | 2 |
   +---+---+---+---+---+---+---+
A  | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
   +---+---+---+---+---+---+---+
Y  | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
   +---+---+---+---+---+---+---+
K  | 0 | 1 | 2 | 2 | 2 | 3 | 4 |
   +---+---+---+---+---+---+---+
P  | 0 | 1 | 2 | 3 | 3 | 3 | 4 |
   +---+---+---+---+---+---+---+
   
</code>
</pre>

### 과정

1. 문자열A, 문자열B의 **한글자씩** 비교해봅니다.
2. 두 문자가 **다르다면 `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중에 큰값을 표시**합니다.
3. 두 문자가 **같다면 `LCS[i - 1][j - 1]` 값을 찾아 `+1`** 합니다.
4. 위 과정을 반복합니다.

최장 공통 문자열을 구하는 과정과 다른 부분은 비교하는 두 문자가 다를 때이다. 비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다.

**`LCS[i - 1][j]`와 `LCS[i][j - 1]`**

부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 계속해서 유지됩니다. ‘현재의 문자를 비교하는 과정’ 이전의 과정이 **`LCS[i - 1][j]`와 `LCS[i][j - 1]`** 입니다.