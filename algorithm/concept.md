# 알고리즘
시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)

    시간 복잡도 : 알고리즘이 실행되는데 걸리는 `연산 횟수`
    공간 복잡도 : 알고리즘이 실행될 때 필요한 `메모리의 양`

## 시간 복잡도의 표기법: Big-O 표기법
시간 복잡도|의미|예제
|---|---|----|
O(1) | 상수 시간|배열에서 특정 원소 접근 arr[i]
O(log n) | 로그 시간 | 이진 탐색(Binary Search)
O(n) | 선형 시간 | 배열의 모든 원소 탐색(반복문 1개)
O(n log n) | 로그-선형 시간 | 퀵 정렬, 병합 정렬
O(n²) | 이차 시간 | 중첩 루프(반복문 2개)
O(2ⁿ) | 지수 시간 | 피보나치 재귀(순수 재귀)
O(n!) | 팩토리얼 시간 | 브루트포스 순열 생성

## 공간 복잡도

공간 복잡도 계산 방법
- 입력 데이터 자체를 저장하는 공간 (보통 무시)
- 추가로 사용하는 배열, 리스트, 재귀 스택 등이 공간 복잡도에 영향을 줌

공간 복잡도|의미|예제
|---|---|----|
O(1) | 추가 메모리를 거의 사용하지 않음|변수 1~2개만 사용
O(log n) | 입력 크기만큼 메모리 필요 | 새로운 배열 생성
O(n) | 2차원 배열 사용 | 그래프 인접 행렬

##  시간 복잡도 vs 공간 복잡도 트레이드오프

일반적으로 시간과 공간은 트레이드오프(trade-off) 관계에 있습니다.
- 시간을 줄이면 공간이 늘어남 → 캐싱, DP (동적 계획법)
- 공간을 줄이면 시간이 늘어남 → 브루트포스, 재귀

예를 들어, 피보나치 수열을 계산할 때:
- 재귀(O(2ⁿ), O(n) 공간)
- 메모이제이션 (O(n), O(n) 공간)
- 반복문 (O(n), O(1) 공간) → 최적화됨

## 알고리즘의 시간 복잡도 및 공간 복잡도 정리

### 📌 1. 정렬 알고리즘 (Sorting Algorithms)

| 알고리즘 | 최선 (Best) | 평균 (Average) | 최악 (Worst) | 공간 복잡도 (Space) | 비고 |
|---------|------------|---------------|--------------|---------------------|------|
| **버블 정렬 (Bubble Sort)** | O(n) | O(n²) | O(n²) | O(1) | 단순하지만 비효율적 |
| **선택 정렬 (Selection Sort)** | O(n²) | O(n²) | O(n²) | O(1) | 항상 O(n²) |
| **삽입 정렬 (Insertion Sort)** | O(n) | O(n²) | O(n²) | O(1) | 거의 정렬된 데이터에 효율적 |
| **병합 정렬 (Merge Sort)** | O(n log n) | O(n log n) | O(n log n) | O(n) | 안정 정렬 |
| **퀵 정렬 (Quick Sort, Hoare 방식)** | O(n log n) | O(n log n) | O(n²) | O(log n) | 평균적으로 빠름 |
| **힙 정렬 (Heap Sort)** | O(n log n) | O(n log n) | O(n log n) | O(1) | 힙을 사용 |
| **계수 정렬 (Counting Sort)** | O(n + k) | O(n + k) | O(n + k) | O(k) | 숫자 범위가 작을 때 유리 |
| **기수 정렬 (Radix Sort)** | O(nk) | O(nk) | O(nk) | O(n + k) | 숫자 범위가 큰 경우 |

---

### 📌 2. 탐색 알고리즘 (Searching Algorithms)

| 알고리즘 | 최선 (Best) | 평균 (Average) | 최악 (Worst) | 공간 복잡도 (Space) | 비고 |
|---------|------------|---------------|--------------|---------------------|------|
| **선형 탐색 (Linear Search)** | O(1) | O(n) | O(n) | O(1) | 순차 검색 |
| **이진 탐색 (Binary Search)** | O(1) | O(log n) | O(log n) | O(1) | 정렬된 배열에서만 사용 가능 |
| **이진 트리 탐색 (BST Search)** | O(1) | O(log n) | O(n) | O(n) | 최악의 경우 O(n) (편향 트리) |
| **해시 탐색 (Hash Search)** | O(1) | O(1) | O(n) | O(n) | 해시 충돌 시 O(n) |

---

### 📌 3. 그래프 알고리즘 (Graph Algorithms)

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 비고 |
|---------|------------|------------|------|
| **너비 우선 탐색 (BFS)** | O(V + E) | O(V) | 큐 사용 (Queue) |
| **깊이 우선 탐색 (DFS)** | O(V + E) | O(V) | 재귀(스택) 사용 |
| **다익스트라 (Dijkstra, 우선순위 큐)** | O((V + E) log V) | O(V) | 최단 경로 (단일 출발) |
| **플로이드 워셜 (Floyd-Warshall)** | O(V³) | O(V²) | 모든 쌍 최단 경로 |
| **벨만 포드 (Bellman-Ford)** | O(VE) | O(V) | 최단 경로 (음수 간선 허용) |
| **크루스칼 (Kruskal, 최소 신장 트리)** | O(E log E) | O(E) | 정렬 기반 |
| **프림 (Prim, 최소 신장 트리)** | O((V + E) log V) | O(V) | 우선순위 큐 |

---

### 📌 4. 동적 프로그래밍 (Dynamic Programming, DP)

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 비고 |
|---------|------------|------------|------|
| **피보나치 (DP, Bottom-Up)** | O(n) | O(n) | O(n) → O(1) 최적화 가능 |
| **0/1 배낭 문제 (Knapsack 0/1)** | O(nW) | O(nW) | n = 아이템 개수, W = 배낭 용량 |
| **LCS (최장 공통 부분 수열)** | O(nm) | O(nm) | 문자열 비교 |
| **행렬 체인 곱셈 (Matrix Chain Multiplication)** | O(n³) | O(n²) | DP 기반 최적화 |