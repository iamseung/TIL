# Longest Common Subsequence, 최장 공통 부분수열

부분수열이기 때문에 문자 사이를 건너뛰어 공통되면서 가장 긴 부분 문자열을 찾으면 됩니다.

<pre>
<code>
if i == 0 or j == 0:  # 마진 설정
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i - 1][j - 1] + 1
else:
	LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1])
</code>
</pre>
---

### 과정

1. 문자열A, 문자열B의 **한글자씩** 비교해봅니다.
2. 두 문자가 **다르다면 `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중에 큰값을 표시**합니다.
3. 두 문자가 **같다면 `LCS[i - 1][j - 1]` 값을 찾아 `+1`** 합니다.
4. 위 과정을 반복합니다.

최장 공통 문자열을 구하는 과정과 다른 부분은 비교하는 두 문자가 다를 때이다. 비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다.

**`LCS[i - 1][j]`와 `LCS[i][j - 1]`**

부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 계속해서 유지됩니다. ‘현재의 문자를 비교하는 과정’ 이전의 과정이 **`LCS[i - 1][j]`와 `LCS[i][j - 1]`** 입니다.

이에 대한 이해를 문제를 통해서 더해보겠습니다.


## 최장 공통 부분 수열, LCS
https://www.acmicpc.net/problem/9251

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제입니다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 `ACAK`가 됩니다. ACAYKP와 CAPCAK 의 LCS 를 계산해보면 아래와 같습니다. 

```
         C   A   P   C   A   K
   +---+---+---+---+---+---+---+
A  | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
   +---+---+---+---+---+---+---+
C  | 0 | 1 | 1 | 1 | 2 | 2 | 2 |
   +---+---+---+---+---+---+---+
A  | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
   +---+---+---+---+---+---+---+
Y  | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
   +---+---+---+---+---+---+---+
K  | 0 | 1 | 2 | 2 | 2 | 3 | 4 |
   +---+---+---+---+---+---+---+
P  | 0 | 1 | 2 | 3 | 3 | 3 | 4 |
   +---+---+---+---+---+---+---+
```

동일한 문자의 경우엔 위의 `대각선 + 1`의 값을 저장하고, 그 외의 경우에는 `위 아래 값 중, 더 큰 값`을 저장하면 됩니다. 이를 코드로 작성하면 아래와 같습니다.


```java
int aLen = A.length();
int bLen = B.length();

int[][] dp = new int[aLen + 1][bLen + 1];

for (int i = 1; i <= aLen; i++) {
   for (int j = 1; j <= bLen; j++) {
         if (A.charAt(i - 1) == B.charAt(j - 1)) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
         } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
         }
   }
}

System.out.println(dp[aLen][bLen]);
```
여기서 주의할 점은 문자가 같지 않는 경우입니다. 같지 않을 경우, 다음 중 어느 경우가 더 긴 LCS를 만들어내는지 비교합니다.

1. A의 이전 문자까지 고려하고, B는 현재 문자까지 고려한 경우 (dp[i - 1][j])
즉, 문자열 A에서 한 글자를 줄이고, B는 그대로 두었을 때의 LCS 길이.

2. A는 현재 문자까지 고려하고, B의 이전 문자까지 고려한 경우 (dp[i][j - 1])
즉, 문자열 B에서 한 글자를 줄이고, A는 그대로 두었을 때의 LCS 길이.

dp 배열의 각 칸 `dp[i][j]` 는 A의 처음 i개 문자와 B의 처음 j개 문자로 이루어진 LCS의 길이를 저장합니다. 예를 들어, **dp[3][2]는 A = "ACA"와 B = "CA"의 LCS 길이**를 나타낸다는 것입니다.

<br>이러한 과정을 통해 dp 의 값을 갱신해가며 두 문자열에 대한 LCS 를 구해낼 수 있습니다. 다음으로 이와 비슷한 개념의 공통 부분 문자열에 대해 정리하겠습니다.


## 공통 부분 문자열
https://www.acmicpc.net/problem/5582

위의 문제와 다른 점은 연속으로 나타나는 부분 문자열을 구해야 한다는 것입니다. 이를 구현한 코드는 아래와 같습니다.

```java
public static void process() {
   int aLen = A.length();
   int bLen = B.length();
   int max = 0;

   int[][] dp = new int[aLen + 1][bLen + 1];

   for (int a = 1; a <= aLen; a++) {
      for (int b = 1; b <= bLen; b++) {
            if (A.charAt(a - 1) == B.charAt(b - 1)) {
               dp[a][b] = dp[a - 1][b - 1] + 1;
               max = Math.max(dp[a][b], max);
            }
      }
   }

   System.out.println(max);
}
```

최장 공통 부분 수열과 다른 점은 연속된 문자열의 길이를 구해야 한다는 것입니다. 그렇기에 문자열이 다를 경우는 제외하고 같은 경우에만 `대각선의 값 + 1` 을 진행하며 연속된 경우에만 값을 갱신하고, 최대값을 갱신하며 이를 출력합니다.
