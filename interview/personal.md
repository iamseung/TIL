개인적으로 기술 면접에 준비하기 위한 문항들입니다.

-----------------------

### JVM 구조

<details>
    <summary> 예비 답안 </summary>
    <br />

- `jvm` 은 자바 가상 머신입니다. 
    - 자바와 운영체제 사이에서 중개자 역할을 수행하며 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 도와줍니다.
- JVM 의 구조는 
    - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈인 `Class Loader`
    - 클래스 로더를 통해 JVM 내의 Runtime Data Area 에 배치된 바이트 코드들을 명령어 단위로 실행하는 `Execution Engine`
    - 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후, 제거하는 역할을 하는 `Garbage Collector`
    - JVM 의 메모리 영역으로, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역인 `Runtime Data Area`
    
</details>

-----------------------

### JVM 의 메모리 구조

<details>
    <summary> 예비 답안 </summary>
    <br />

- JVM 의 메모리 구조는 모든 쓰레드에서 공유되는 Method 영역과 Heap 영역, 나머지 영역인 PC Register, Stack, Native Method Stack 영역으로 구분할 수 있습니다.

    - `Method 영역` → 모든 스레드가 공유하는 영역으로, 클래스/인터페이스/메소드/필드/static 변수 등의 바이트 코드를 보관합니다.
    - `Heap 영역` → 모든 스레드가 공유하는 영역으로, new 키워드로 생성된 모든 객체와 배열이 저장되는 영역입니다. 또한 메소드 영역에 로드된 클래스만 생성이 가능하고 GC 가 참조되지 않는 메모리를 확인하고 제거하는 영역입니다.
    - `PC Register` → 스레드가 시작될 때 생성되며, 스레드가 어떤 부분을 무슨 명령어로 실행해야 할 지에 대한 기록을 하는 부분으로, JVM 명령의 주소를 가집니다.
    - `Stack` → 메서드 호출 시마다 각각의 스택 프레임이 생성됩니다. 그리고 메서드 안에서 사용되는 값들을 젖아하고 , 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임별로 됩니다.
    - `Native Method Stack` → 자바 외의 언어로 작성된 네이티브 코드를 위한 스택입니다.
    
</details>

-----------------------

### Spring Framework 란

<details>
    <summary> 예비 답안 </summary>
    <br />

- 자바 기반 애플리케이션 개발을 지원하는 오픈 소스 프레임워크 입니다.
- 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션입니다.
    - 대규모 데이터 처리와 트랜잭션이 동시에 여러 사용자로부터 행해지는 매우 큰 규모의 환경을 매니징하는 엔터프라이즈 환경
- Spring Framework 는 경량 컨테이너로 자바 객체를 담고 직접 관리합니다.
    
</details>

-----------------------

### Spring Framework 를 사용하는 이유

<details>
    <summary> 예비 답안 </summary>
    <br />

- 생산성을 높이고 유지보수를 용이하게 할 수 있습니다. 
- 프로젝트를 여러 모듈로 나눠, 각 모듈이 독립적으로 개발/배포/테스트가 가능하게 할 수 있습니다.
    - 모듈화된 아키텍처를 구현할 수 있으며 Spring 은 다양한 기술과 통합이 가능합니다.
    - 필요에 따라 새 기능을 추가하거나 확장에 용이합니다.

- 특징
1. `IoC` → `객체 생성과 의존성 관리를 개발자가 아닌 프레임워크가 대신 처리하여 코드의 결합도를 낮추고 테스트를 용이하게 만든다.` 즉, 객체를 매번 new 로 생성하지 않고, 컨테이너가 필요 시 주입하기 때문에 코드의 복잡성을 줄이고, 개발자가 비즈니스 로직에만 집중할 수 있게 해줍니다.
2. `AOP` → 로깅, 트랜잭션 관리와 같은 횡단 관심사를 분리해 코드의 가독성과 재사용성을 높인다. 즉, 공통된 기능을 비즈니스 로직과 분리할 수 있다는 장점으로 유지보수에 용이하다.
3. `DI` → `의존성 주입, 클래스 간 결합도를 낮추고, 새로운 요구사항에 맞춰 변경해야 할 부분을 최소화 할 수 있습니다`. 특정 구현체가 변경 시 인터페이스를 통해 쉽게 교체가 가능합니다.
4. `데이터 접근 간소화` → JDBC, JPA 와 같은 데이터 접근 기술과의 통합을 제공하여 데이터 처리를 간단하게 만들어줍니다. 즉, 데이터베이스 작업에 필요한 반복적인 코드를 대폭 줄일 수 있습니다.
5. `모듈화된 설계` → Core, Data Access, Web, Security 등 다양한 모듈로 구성되어 필요에 따라 선택적으로 사용할 수 있다.
6. 유연한 설정 방식 → XML, Java Config, 어노테이션 기반 설정을 모두 지원한다. 즉, 설정 파일의 중앙화 때문에 환경 변화에 유연하게 대응이 가능합니다.
    
</details>

-----------------------

### logger 를 지향하고, System.out.println() 을 지양하는 이유

<details>
    <summary> 예비 답안 </summary>
    <br />

1. 성능 문제

    System.out.println(stdout) 은 Blocking I/O 로 동작하므로, 로그를 출력하는 동안 애플리케이션이 멈출 수 있습니다. 특히, 대량의 로그를 출력하는 경우 성능이 크게 저하됩니다. 예시로 stdout 을 다량 사용하면 GC 의 영향을 받아 애플리케이션 응답 속도가 느려질 수 있습니다.<br>
    또한, System.out 은 synchronized 메서드(Thread-safe)라서 여러 스레드가 동시에 로그를 출력할 경우 성능 병목이 발생할 수 있습니다.
    
    💡 Blocking I/O 는 입출력(I/O) 작업이 완료될 때까지 프로그램 실행이 멈추는 방식으로, 한 번에 하나의 작업만 수행되며 현재 작업이 끝나야만 다읍 작업이 시작될 수 있습니다.

    💡 Thread-safe 란, 여러 개의 스레드가 동시에 같은 자원에 접근해도 문제가 발생하지 않는 상태를 의미합니다. 즉, 여러 스레드가 동시에 실행해도 데이터가 손상되지 않습니다. 하지만 Thread-safe 를 위해 synchronized 키워드를 사용하므로 성능 병목(Bottleneck)이 발생합니다. 즉, 여러 스레드가 동시에 실행되면 한 스레드가 출력하는 동안 다른 스레드는 대기합니다.

2. 로그 관리 효율성 증가

    stdout 으로 출력하면 전체 로그를 출력해야 하므로 필요없는 로그까지 출력될 수 있습니다. 또한 stdout 은 서버를 재시작하면 로그가 사라지는 휘발성이기 때문에 log4j 를 사용하여 파일 또는 원격 서버로 저장이 가능합니다.
</details>

-----------------------

### Filter 과 Interceptor

<details>
    <summary> 예비 답안 </summary>
    <br />

Filter 는 HTTP 요청을 가로채어, 특정 작업을 수행할 수 있도록 하는 컴포넌트입니다. 주로 보안/로깅/데이터 처리/요청 수정 등 다양한 작업을 처리할 수 있습니다.

Intercepter 는 Spring 의 HandlerIntercepter 인터페이스를 구현하여 요청 전/후 및 완료 단계에서 처리 로직을 삽입할 수 있다.



</details>

-----------------------