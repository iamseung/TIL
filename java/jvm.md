JVM의 구조와 Java의 실행방식을 설명해주세요.

# JVM 의 동작 원리
![poster](../image/jvm/jvm1.png)

JVM 의 동작 원리는 크게 3가지로 나뉩니다.

1. 코드작성

    Java 로 코드를 작성합니다. 작성한 Java 코드는 `.java` 파일로 저장됩니다.

2. 컴파일

    `.java` 파일이 자바 컴파일러(javac)에 의해 `.class` 파일로 변환됩니다. 이 `.class` 파일은 자바 코드가 바이트 코드(JVM 에서 작동하도록 만든 이진 코드)로 변환되어 있습니다.
    
    여기서 바이트 코드란 JVM 에서 작동하도록 만든 이진 코드입니다. 즉, JVM 이 이해할 수 있는 언어로 변환된 코드이며 명령어의 크기가 1 바이트라서 자바 바이트 코드라고 불리고, 자바 코드를 배포하는 가장 작은 단위입니다.

3. JVM 실행

    `.class` 파일의 바이트 코드를 읽고, 각각의 컴퓨터가 이해할 수 있는 기계어로 변환하여 실행합니다.

# JVM 의 구조
![poster](../image/jvm/jvm2.png)


jvm은 크게 클래스 로더(class loader), 실행엔진(execution engine), 런타임 데이터 영역(runtime data area), GC(Garbage Collector)으로 구성됩니다. 
자바 컴파일러는 우리가 자바로 작성한 .java 파일을 자바 바이트 코드인 .class파일로 컴파일 해줍니다. 
자바 가상머신은 이 바이트 코드를 실행함으로써 하드웨어나 운영체제 등과는 독립적으로 동일하게 동작할 것을 보장합니다. 
이후 jvm 을 실행하면서 클래스 로더는  .class 파일(자바 바이트 코드)을 런타임 데이터 영역에 로드해주는 역할을 합니다.

## 클래스 로더
자바는 컴파일 타임이 아니라 런타임(class 파일을 실행할 때) 시점, 즉 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하며 초기화 합니다. -> 동적 로딩

이 동적 로딩을 담당하는 것이 바로 클래스 로더입니다. 실행엔진이 클래스 로더에 의해 런타임 데이터 영역에 올라온 바이트 코드를 실행하면서 애플리케이션이 실행됩니다.

## 런타임 데이터 영역
JVM 이 운영 체제 위에서 실행될 때, 할당 받는 메모리 영역으로 다음과 같이 분류됩니다.

**Method 영역과 Heap 영역은 모든 쓰레드에서 공유되고, 나머지 영역(pc register, jvm stack, native method stack)은 쓰레드마다 각각 존재합니다.**

![poster](../image/jvm/jvm3.png)

### Method 영역
모든 스레드가 공유하는 영역으로, 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드와 변수 정보 등)를 저장합니다.

### Heap 영역
모든 스레드가 공유하는 영역으로, 생성된 모든 객체와 배열이 저장되는 영역입니다.

Stack 영역과 다르게, 보관되는 메모리가 호출이 끝나더라도 삭제되지 않고 유지됩니다. 그러다 GC 가 더 이상 참조되지 않는 인스턴스가 있다면 제거합니다.

### Stack 영역
스레드마다 별도로 존재하며, 스레드의 메소드 호출과 로컬 변수 등을 관리합니다.
pc register는 현재 수행중인 jvm 명령 주소를 가지고 있습니다. jvm stack은 스텍 프레임을 저장하는 스택으로 스택프레임은 메서드가 수행될 때마다 생성되고 메서드가 종료되면 제거됩니다. 
(스택 프레임에는 지역 변수 배열, 피연산자 스택, 현재 실행중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스의 정보가 있습니다.) 
native method stack은 자바 외의 언어로 작성된 네이티브 코드를 위한 스택입니다. 모든 스레드가 공유하는 영역은 heap, method area, runtime constant pool이 있습니다. heap 영역은 인스턴스, 객체가 저장되는 공간으로 가비지 컬렉션의 대상입니다. 
method area는 jvm이 읽어들인 클래스와 인터페이스에 대한 runtime constant pool을 포함하며, 클래스의 필드와 메서드 정보, static 변수, 메서드의 바이트 코드 정보를 포함하고 있습니다. 
마지막으로 runtime constant pool은 method area에 포함되며, 각 클래스와 인터페이스의 상수 정보와 메서드와 필드에 대한 레퍼런스를 담은 테이블정보를 갖고 있습니다.

## 실행엔진
메모리에 적재된 바이트코드(.class) 를 기계어로 변환해 명령어 단위로 읽어 실행하는 역할을 합니다.
위와 같은 역할을 수행하기 위해 두가지 방식을 사용합니다.

### 1. 인터프리터 방식
바이트코드(.class) 를 한 줄씩 읽어서 실행합니다. 하지만 같은 코드를 실행할 때마다 바이트 코드를 매번 해석해야해서 속도가 느리다는 단점이 있습니다.

### 2. JIT(Just In Time) Compiler
인터프리터의 단점을 보완하기 위해 도입된 것으로 프로그램 실행 중에 바이트 코드 전체 또는 일부를 네이티브 코드로 컴파일하고, 직접 실행합니다.

설명만 봤을 때는 JIT 컴파일러만 사용할 것처럼 보이지만 JVM 실행 엔진에서는 이 두가지 방식을 함께 사용합니다.

프로그램 실행 초기에는 인터프리터 방식으로 빠르게 시작하고, 실행 중에 JIT 컴파일러가 분석을 통해 성능이 중요한 부분을 식별해 네이티브 코드로 컴파일합니다.

## GC(Garbage Collector)
힙 메모리 영역에 생성된 객체들 중, 더 이상 참조되지 않는 객체를 자동으로 검색해 제거합니다.


URL : https://seung-seok.tistory.com/entry/Java-JVM-%EC%9D%B4%EB%9E%80